# -*- coding: utf-8 -*-
"""notebookA4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18dMPve3-JOZSCskZseNluhERgteknuPZ
"""

from torch import nn, cuda, hub, sigmoid, tensor, save, load, no_grad, max
from torch.utils.data import Dataset, ConcatDataset, DataLoader
from torch.optim import Adam

from torchvision import datasets, transforms
from numpy.random import randint
from tqdm.auto import tqdm

# from google.colab import drive
# drive.mount('/content/drive')

if cuda.is_available():
  DEVICE = 'cuda'
else:
  DEVICE = 'cpu'

print(f'using device: {DEVICE}')

TRANSFORM = transforms.Compose([
        transforms.Resize((128, 128)),
        transforms.ToTensor()
    ])

DOMAIN_EPOCHS = 1
PRED_EPOCHS = 1
BATCH_SIZE = 16
LEARNING_RATE = 0.01

class DualModel(nn.Module):
    def __init__(self, train_mode: bool=False, domain: bool=False, num_classes: int=10):
        super().__init__()
        self.prediction_model = hub.load('pytorch/vision:v0.10.0', 'mobilenet_v2', weights=None)
        self.prediction_model.classifier[1] = nn.Linear(self.prediction_model.last_channel, num_classes)
        self.prediction_model.to(DEVICE)

        self.domain_model = hub.load('pytorch/vision:v0.10.0', 'mobilenet_v2', weights=None)
        self.domain_model.classifier[1] = nn.Linear(self.domain_model.last_channel, 1)
        self.domain_model.to(DEVICE)

        self.train_mode = train_mode
        self.domain = domain

    def forward(self, imgs):
        """
        If the model is in training mode:
        -> If the model is in domain mode:
        ---> Train domain model
        -> Otherwise:
        ---> Train prediction model

        If the model is in prediction mode:
        -> If the image is predicted to be in-domain:
        ---> Use prediction model to predict class
        -> Otherwise
        ---> Predict a random class
        """
        # training flow
        if self.train_mode:
            # if training domain model
            if self.domain:
                domain_logits = self.domain_model(imgs)
                domain_logits = domain_logits.view(-1, 1)
                return domain_logits
            # if training prediction model
            else:
                class_logits = self.prediction_model(imgs)
                return class_logits

        # normal prediction flow
        domain_logits = self.domain_model(imgs)
        domain_logits = domain_logits.view(-1, 1)
        domain_probs = sigmoid(domain_logits)

        class_logits = self.prediction_model(imgs)

        for i, p in enumerate(domain_probs.flatten()):
            if p < 0.5:
                artificial_prediction = tensor([0] * 10)
                rand_num = randint(0, 10)
                artificial_prediction[rand_num] = 1
                class_logits[i] = artificial_prediction
        return class_logits

class BinaryDataLoader(Dataset):
    def __init__(self, dataset, label):
        self.dataset = dataset
        self.label = label

    def __len__(self):
        return len(self.dataset)

    def __getitem__(self, index):
        item, _ = self.dataset[index]
        label = self.label
        return item, label

def get_domain_data(in_path, out_path):
    in_data = datasets.ImageFolder(in_path, transform=TRANSFORM)
    out_data = datasets.ImageFolder(out_path, transform=TRANSFORM)

    in_data_loader = BinaryDataLoader(in_data, 1)
    out_data_loader = BinaryDataLoader(out_data, 0)

    combined_dataset = ConcatDataset([in_data_loader, out_data_loader])
    combined_data_loader = DataLoader(combined_dataset, batch_size=BATCH_SIZE, shuffle=True)

    return combined_data_loader

def learn(path_to_in_domain: str, path_to_out_domain: str):
    in_data = datasets.ImageFolder(path_to_in_domain, transform=TRANSFORM)
    in_data_loader = DataLoader(in_data, batch_size=BATCH_SIZE, shuffle=True)

    comb = get_domain_data(path_to_in_domain, path_to_out_domain)

    model = DualModel()

    # train domain
    model.train()
    model.train_mode = True
    model.domain = True

    optimizer = Adam(model.parameters(), lr=1e-4)
    criterion = nn.BCEWithLogitsLoss()

    for e in range(DOMAIN_EPOCHS):
        print(f'epoch: {e}')
        running_loss = 0.
        for i, data in tqdm(enumerate(comb), total=len(comb)):
            inputs, labels = data
            inputs = inputs.to(DEVICE)

            labels = labels.view(-1, 1)
            labels = labels.to(DEVICE)

            optimizer.zero_grad()
            outputs = model(inputs)

            loss = criterion(outputs.float(), labels.float())
            running_loss += loss.item()
            loss.backward()

            optimizer.step()


        print(f'running loss for epoch {e}: {running_loss}')


    # train prediction
    model.train()
    model.train_mode = True
    model.domain = False

    optimizer = Adam(model.parameters(), lr=1e-4)
    criterion = nn.CrossEntropyLoss()

    for e in range(PRED_EPOCHS):
        print(f'epoch: {e}')
        running_loss = 0.
        for i, data in tqdm(enumerate(in_data_loader), total=len(in_data_loader)):
            inputs, labels = data
            inputs = inputs.to(DEVICE)
            labels = labels.to(DEVICE)

            optimizer.zero_grad()
            outputs = model(inputs)

            loss = criterion(outputs, labels)
            running_loss += loss.item()
            loss.backward()

            optimizer.step()
        print(f'running loss for epoch {e}: {running_loss}')
    save(model.state_dict(), 'myModel.pth')
    return model

def accuracy(path_to_eval_folder: str, model) -> float:
    data = datasets.ImageFolder(path_to_eval_folder, transform=TRANSFORM)
    data_loader = DataLoader(data, batch_size=BATCH_SIZE, shuffle=True)

    model.train_mode = False
    model.eval()

    correct = 0
    total = 0

    with no_grad():
        for inputs, labels in tqdm(data_loader, total=len(data_loader)):
            inputs = inputs.to(DEVICE)
            labels = labels.to(DEVICE)

            outputs = model(inputs)
            outputs = outputs.view(-1, 10)
            outputs = outputs.to(DEVICE)

            _, predicted = max(outputs, dim=1)

            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    return correct/total

# model = DualModel()
# model = learn('drive/MyDrive/A4data/in-domain-train', 'drive/MyDrive/A4data/out-domain-train')
model = learn('A4data/in-domain-train', 'A4data/out-domain-train')


new_model = DualModel()
new_model.to(DEVICE)
state_dict = load('myModel.pth', map_location=DEVICE)
new_model.load_state_dict(state_dict)

# acc = accuracy('drive/MyDrive/A4data/in-domain-eval', new_model)
acc = accuracy('A4data/in-domain-eval', new_model)
print(f'accuracy on in domain: {acc}')
# acc_2 = accuracy('drive/MyDrive/A4data/out-domain-eval', new_model)
acc_2 = accuracy('A4data/out-domain-eval', new_model)
print(f'accuracy on out domain: {acc_2}')

def test_domain_model(model, in_dom, out_dom):
    comb = get_domain_data(in_dom, out_dom)

    model.train_mode = True
    model.domain = True
    model.eval()

    correct = 0
    total = 0

    with no_grad():
        for inputs, labels in tqdm(comb, total=len(comb)):
            inputs = inputs.to(DEVICE)
            labels = labels.to(DEVICE)
            labels = labels.view(-1, 1)

            logits = model(inputs)
            logits = logits.view(-1, 1)
            probs = sigmoid(logits)

            preds = (probs > 0.5).long()

            total += labels.size(0)
            correct += (preds == labels).sum().item()

    return correct/total

# exp = test_domain_model(new_model, 'drive/MyDrive/A4data/in-domain-eval', 'drive/MyDrive/A4data/out-domain-eval')
exp = test_domain_model(new_model, 'A4data/in-domain-eval', 'A4data/out-domain-eval')
print(f'accuracy of domain model: {exp}')

def test_prediction_model(model, in_dom):
    data = datasets.ImageFolder(in_dom, transform=TRANSFORM)
    data_loader = DataLoader(data, batch_size=BATCH_SIZE, shuffle=True)

    model.train_mode = True
    model.domain = False
    model.eval()

    correct = 0
    total = 0

    with no_grad():
        for inputs, labels in tqdm(data_loader, total=len(data_loader)):
            inputs = inputs.to(DEVICE)
            labels = labels.to(DEVICE)

            outputs = model(inputs)
            outputs = outputs.view(-1, 10)
            outputs = outputs.to(DEVICE)

            _, predicted = max(outputs, dim=1)

            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    return correct/total

# exp = test_prediction_model(new_model, 'drive/MyDrive/A4data/in-domain-eval')
exp = test_prediction_model(new_model, 'A4data/in-domain-eval')
print(f'accuracy of prediction model: {exp}')